// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal
{
  class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2eproto
{
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto;
namespace nrpc
{
  class HTTPMethod;
  struct HTTPMethodDefaultTypeInternal;
  extern HTTPMethodDefaultTypeInternal _HTTPMethod_default_instance_;
} // namespace nrpc
PROTOBUF_NAMESPACE_OPEN
template <>
::nrpc::HTTPMethod *Arena::CreateMaybeMessage<::nrpc::HTTPMethod>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace nrpc
{

  enum HTTPMethod__HTTPMethod : int
  {
    HTTPMethod__HTTPMethod_GET = 0,
    HTTPMethod__HTTPMethod_POST = 1,
    HTTPMethod__HTTPMethod_HEAD = 2,
    HTTPMethod__HTTPMethod_OPTIONS = 3,
    HTTPMethod__HTTPMethod_PUT = 4,
    HTTPMethod__HTTPMethod_PATCH = 5,
    HTTPMethod__HTTPMethod_DELETE = 6,
    HTTPMethod__HTTPMethod_TRACE = 7,
    HTTPMethod__HTTPMethod_CONNECT = 8,
    HTTPMethod__HTTPMethod_HTTPMethod__HTTPMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    HTTPMethod__HTTPMethod_HTTPMethod__HTTPMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
  };
  bool HTTPMethod__HTTPMethod_IsValid(int value);
  constexpr HTTPMethod__HTTPMethod HTTPMethod__HTTPMethod__HTTPMethod_MIN = HTTPMethod__HTTPMethod_GET;
  constexpr HTTPMethod__HTTPMethod HTTPMethod__HTTPMethod__HTTPMethod_MAX = HTTPMethod__HTTPMethod_CONNECT;
  constexpr int HTTPMethod__HTTPMethod__HTTPMethod_ARRAYSIZE = HTTPMethod__HTTPMethod__HTTPMethod_MAX + 1;

  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *HTTPMethod__HTTPMethod_descriptor();
  template <typename T>
  inline const std::string &HTTPMethod__HTTPMethod_Name(T enum_t_value)
  {
    static_assert(::std::is_same<T, HTTPMethod__HTTPMethod>::value ||
                      ::std::is_integral<T>::value,
                  "Incorrect type passed to function HTTPMethod__HTTPMethod_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
        HTTPMethod__HTTPMethod_descriptor(), enum_t_value);
  }
  inline bool HTTPMethod__HTTPMethod_Parse(
      ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HTTPMethod__HTTPMethod *value)
  {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HTTPMethod__HTTPMethod>(
        HTTPMethod__HTTPMethod_descriptor(), name, value);
  }
  enum ConnType : int
  {
    ConnType_Short = 0,
    ConnType_Single = 1,
    ConnType_Pool = 2,
    ConnType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    ConnType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
  };
  bool ConnType_IsValid(int value);
  constexpr ConnType ConnType_MIN = ConnType_Short;
  constexpr ConnType ConnType_MAX = ConnType_Pool;
  constexpr int ConnType_ARRAYSIZE = ConnType_MAX + 1;

  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *ConnType_descriptor();
  template <typename T>
  inline const std::string &ConnType_Name(T enum_t_value)
  {
    static_assert(::std::is_same<T, ConnType>::value ||
                      ::std::is_integral<T>::value,
                  "Incorrect type passed to function ConnType_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
        ConnType_descriptor(), enum_t_value);
  }
  inline bool ConnType_Parse(
      ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnType *value)
  {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnType>(
        ConnType_descriptor(), name, value);
  }
  enum RpcStatus : int
  {
    RpcStatus_OK = 0,
    RpcStatus_INVALID_PATH = 1,
    RpcStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    RpcStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
  };
  bool RpcStatus_IsValid(int value);
  constexpr RpcStatus RpcStatus_MIN = RpcStatus_OK;
  constexpr RpcStatus RpcStatus_MAX = RpcStatus_INVALID_PATH;
  constexpr int RpcStatus_ARRAYSIZE = RpcStatus_MAX + 1;

  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *RpcStatus_descriptor();
  template <typename T>
  inline const std::string &RpcStatus_Name(T enum_t_value)
  {
    static_assert(::std::is_same<T, RpcStatus>::value ||
                      ::std::is_integral<T>::value,
                  "Incorrect type passed to function RpcStatus_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
        RpcStatus_descriptor(), enum_t_value);
  }
  inline bool RpcStatus_Parse(
      ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RpcStatus *value)
  {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcStatus>(
        RpcStatus_descriptor(), name, value);
  }
  enum ParseProtocolStatus : int
  {
    ParseProtocol_Success = 0,
    ParseProtocol_Error = 1,
    ParseProtocol_NoEnoughData = 2,
    ParseProtocol_TryAnotherProtocol = 3,
    ParseProtocol_PartSuccess = 4,
    ParseProtocolStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    ParseProtocolStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
  };
  bool ParseProtocolStatus_IsValid(int value);
  constexpr ParseProtocolStatus ParseProtocolStatus_MIN = ParseProtocol_Success;
  constexpr ParseProtocolStatus ParseProtocolStatus_MAX = ParseProtocol_PartSuccess;
  constexpr int ParseProtocolStatus_ARRAYSIZE = ParseProtocolStatus_MAX + 1;

  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *ParseProtocolStatus_descriptor();
  template <typename T>
  inline const std::string &ParseProtocolStatus_Name(T enum_t_value)
  {
    static_assert(::std::is_same<T, ParseProtocolStatus>::value ||
                      ::std::is_integral<T>::value,
                  "Incorrect type passed to function ParseProtocolStatus_Name.");
    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
        ParseProtocolStatus_descriptor(), enum_t_value);
  }
  inline bool ParseProtocolStatus_Parse(
      ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParseProtocolStatus *value)
  {
    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParseProtocolStatus>(
        ParseProtocolStatus_descriptor(), name, value);
  }
  // ===================================================================

  class HTTPMethod final : public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:nrpc.HTTPMethod) */
  {
  public:
    inline HTTPMethod() : HTTPMethod(nullptr) {}
    explicit constexpr HTTPMethod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    HTTPMethod(const HTTPMethod &from);
    HTTPMethod(HTTPMethod &&from) noexcept
        : HTTPMethod()
    {
      *this = ::std::move(from);
    }

    inline HTTPMethod &operator=(const HTTPMethod &from)
    {
      CopyFrom(from);
      return *this;
    }
    inline HTTPMethod &operator=(HTTPMethod &&from) noexcept
    {
      if (this == &from)
        return *this;
      if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
          && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
      )
      {
        InternalSwap(&from);
      }
      else
      {
        CopyFrom(from);
      }
      return *this;
    }

    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor()
    {
      return GetDescriptor();
    }
    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor()
    {
      return default_instance().GetMetadata().descriptor;
    }
    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection()
    {
      return default_instance().GetMetadata().reflection;
    }
    static const HTTPMethod &default_instance()
    {
      return *internal_default_instance();
    }
    static inline const HTTPMethod *internal_default_instance()
    {
      return reinterpret_cast<const HTTPMethod *>(
          &_HTTPMethod_default_instance_);
    }
    static constexpr int kIndexInFileMessages =
        0;

    friend void swap(HTTPMethod &a, HTTPMethod &b)
    {
      a.Swap(&b);
    }
    inline void Swap(HTTPMethod *other)
    {
      if (other == this)
        return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() != nullptr &&
          GetOwningArena() == other->GetOwningArena())
      {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
      if (GetOwningArena() == other->GetOwningArena())
      {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
        InternalSwap(other);
      }
      else
      {
        ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
      }
    }
    void UnsafeArenaSwap(HTTPMethod *other)
    {
      if (other == this)
        return;
      GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
      InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    HTTPMethod *New(::PROTOBUF_NAMESPACE_ID::Arena *arena = nullptr) const final
    {
      return CreateMaybeMessage<HTTPMethod>(arena);
    }
    using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
    inline void CopyFrom(const HTTPMethod &from)
    {
      ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
    }
    using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
    void MergeFrom(const HTTPMethod &from)
    {
      ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
    }

  public:
  private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
      return "nrpc.HTTPMethod";
    }

  protected:
    explicit HTTPMethod(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                        bool is_message_owned = false);

  private:
  public:
    static const ClassData _class_data_;
    const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *GetClassData() const final;

    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------

    typedef HTTPMethod__HTTPMethod _HTTPMethod;
    static constexpr _HTTPMethod GET =
        HTTPMethod__HTTPMethod_GET;
    static constexpr _HTTPMethod POST =
        HTTPMethod__HTTPMethod_POST;
    static constexpr _HTTPMethod HEAD =
        HTTPMethod__HTTPMethod_HEAD;
    static constexpr _HTTPMethod OPTIONS =
        HTTPMethod__HTTPMethod_OPTIONS;
    static constexpr _HTTPMethod PUT =
        HTTPMethod__HTTPMethod_PUT;
    static constexpr _HTTPMethod PATCH =
        HTTPMethod__HTTPMethod_PATCH;
    static constexpr _HTTPMethod DELETE =
        HTTPMethod__HTTPMethod_DELETE;
    static constexpr _HTTPMethod TRACE =
        HTTPMethod__HTTPMethod_TRACE;
    static constexpr _HTTPMethod CONNECT =
        HTTPMethod__HTTPMethod_CONNECT;
    static inline bool _HTTPMethod_IsValid(int value)
    {
      return HTTPMethod__HTTPMethod_IsValid(value);
    }
    static constexpr _HTTPMethod _HTTPMethod_MIN =
        HTTPMethod__HTTPMethod__HTTPMethod_MIN;
    static constexpr _HTTPMethod _HTTPMethod_MAX =
        HTTPMethod__HTTPMethod__HTTPMethod_MAX;
    static constexpr int _HTTPMethod_ARRAYSIZE =
        HTTPMethod__HTTPMethod__HTTPMethod_ARRAYSIZE;
    static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *
    _HTTPMethod_descriptor()
    {
      return HTTPMethod__HTTPMethod_descriptor();
    }
    template <typename T>
    static inline const std::string &_HTTPMethod_Name(T enum_t_value)
    {
      static_assert(::std::is_same<T, _HTTPMethod>::value ||
                        ::std::is_integral<T>::value,
                    "Incorrect type passed to function _HTTPMethod_Name.");
      return HTTPMethod__HTTPMethod_Name(enum_t_value);
    }
    static inline bool _HTTPMethod_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
                                         _HTTPMethod *value)
    {
      return HTTPMethod__HTTPMethod_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:nrpc.HTTPMethod)
  private:
    class _Internal;

    template <typename T>
    friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    friend struct ::TableStruct_protocol_2eproto;
  };
  // ===================================================================

  // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
  // HTTPMethod

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

  // @@protoc_insertion_point(namespace_scope)

} // namespace nrpc

PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::nrpc::HTTPMethod__HTTPMethod> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::nrpc::HTTPMethod__HTTPMethod>()
{
  return ::nrpc::HTTPMethod__HTTPMethod_descriptor();
}
template <>
struct is_proto_enum<::nrpc::ConnType> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::nrpc::ConnType>()
{
  return ::nrpc::ConnType_descriptor();
}
template <>
struct is_proto_enum<::nrpc::RpcStatus> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::nrpc::RpcStatus>()
{
  return ::nrpc::RpcStatus_descriptor();
}
template <>
struct is_proto_enum<::nrpc::ParseProtocolStatus> : ::std::true_type
{
};
template <>
inline const EnumDescriptor *GetEnumDescriptor<::nrpc::ParseProtocolStatus>()
{
  return ::nrpc::ParseProtocolStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
