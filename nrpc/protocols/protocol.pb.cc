// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#include "protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace nrpc
{
  constexpr HTTPMethod::HTTPMethod(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized) {}
  struct HTTPMethodDefaultTypeInternal
  {
    constexpr HTTPMethodDefaultTypeInternal()
        : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
    ~HTTPMethodDefaultTypeInternal() {}
    union
    {
      HTTPMethod _instance;
    };
  };
  PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HTTPMethodDefaultTypeInternal _HTTPMethod_default_instance_;
} // namespace nrpc
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_protocol_2eproto[1];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *file_level_enum_descriptors_protocol_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const **file_level_service_descriptors_protocol_2eproto = nullptr;

const uint32_t TableStruct_protocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    ~0u, // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::nrpc::HTTPMethod, _internal_metadata_),
    ~0u, // no _extensions_
    ~0u, // no _oneof_case_
    ~0u, // no _weak_field_map_
    ~0u, // no _inlined_string_donated_
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    {0, -1, -1, sizeof(::nrpc::HTTPMethod)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const *const file_default_instances[] = {
    reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message *>(&::nrpc::_HTTPMethod_default_instance_),
};

const char descriptor_table_protodef_protocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
    "\n\016protocol.proto\022\004nrpc\"}\n\nHTTPMethod\"o\n\013"
    "_HTTPMethod\022\007\n\003GET\020\000\022\010\n\004POST\020\001\022\010\n\004HEAD\020\002"
    "\022\013\n\007OPTIONS\020\003\022\007\n\003PUT\020\004\022\t\n\005PATCH\020\005\022\n\n\006DEL"
    "ETE\020\006\022\t\n\005TRACE\020\007\022\013\n\007CONNECT\020\010*F\n\010ConnTyp"
    "e\022\022\n\016ConnType_Short\020\000\022\023\n\017ConnType_Single"
    "\020\001\022\021\n\rConnType_Pool\020\002*9\n\tRpcStatus\022\020\n\014Rp"
    "cStatus_OK\020\000\022\032\n\026RpcStatus_INVALID_PATH\020\001"
    "*\256\001\n\023ParseProtocolStatus\022\031\n\025ParseProtoco"
    "l_Success\020\000\022\027\n\023ParseProtocol_Error\020\001\022\036\n\032"
    "ParseProtocol_NoEnoughData\020\002\022$\n ParsePro"
    "tocol_TryAnotherProtocol\020\003\022\035\n\031ParseProto"
    "col_PartSuccess\020\004B\003\200\001\001b\006proto3";
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_protocol_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto = {
    false,
    false,
    470,
    descriptor_table_protodef_protocol_2eproto,
    "protocol.proto",
    &descriptor_table_protocol_2eproto_once,
    nullptr,
    0,
    1,
    schemas,
    file_default_instances,
    TableStruct_protocol_2eproto::offsets,
    file_level_metadata_protocol_2eproto,
    file_level_enum_descriptors_protocol_2eproto,
    file_level_service_descriptors_protocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable *descriptor_table_protocol_2eproto_getter()
{
  return &descriptor_table_protocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_protocol_2eproto(&descriptor_table_protocol_2eproto);
namespace nrpc
{
  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *HTTPMethod__HTTPMethod_descriptor()
  {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protocol_2eproto);
    return file_level_enum_descriptors_protocol_2eproto[0];
  }
  bool HTTPMethod__HTTPMethod_IsValid(int value)
  {
    switch (value)
    {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
    }
  }

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
  constexpr HTTPMethod__HTTPMethod HTTPMethod::GET;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::POST;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::HEAD;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::OPTIONS;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::PUT;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::PATCH;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::DELETE;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::TRACE;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::CONNECT;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::_HTTPMethod_MIN;
  constexpr HTTPMethod__HTTPMethod HTTPMethod::_HTTPMethod_MAX;
  constexpr int HTTPMethod::_HTTPMethod_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *ConnType_descriptor()
  {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protocol_2eproto);
    return file_level_enum_descriptors_protocol_2eproto[1];
  }
  bool ConnType_IsValid(int value)
  {
    switch (value)
    {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
    }
  }

  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *RpcStatus_descriptor()
  {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protocol_2eproto);
    return file_level_enum_descriptors_protocol_2eproto[2];
  }
  bool RpcStatus_IsValid(int value)
  {
    switch (value)
    {
    case 0:
    case 1:
      return true;
    default:
      return false;
    }
  }

  const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *ParseProtocolStatus_descriptor()
  {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_protocol_2eproto);
    return file_level_enum_descriptors_protocol_2eproto[3];
  }
  bool ParseProtocolStatus_IsValid(int value)
  {
    switch (value)
    {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
    }
  }

  // ===================================================================

  class HTTPMethod::_Internal
  {
  public:
  };

  HTTPMethod::HTTPMethod(::PROTOBUF_NAMESPACE_ID::Arena *arena,
                         bool is_message_owned)
      : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned)
  {
    // @@protoc_insertion_point(arena_constructor:nrpc.HTTPMethod)
  }
  HTTPMethod::HTTPMethod(const HTTPMethod &from)
      : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase()
  {
    _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:nrpc.HTTPMethod)
  }

  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HTTPMethod::_class_data_ = {
      ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
      ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
  };
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData *HTTPMethod::GetClassData() const { return &_class_data_; }

  ::PROTOBUF_NAMESPACE_ID::Metadata HTTPMethod::GetMetadata() const
  {
    return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
        &descriptor_table_protocol_2eproto_getter, &descriptor_table_protocol_2eproto_once,
        file_level_metadata_protocol_2eproto[0]);
  }

  // @@protoc_insertion_point(namespace_scope)
} // namespace nrpc
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::nrpc::HTTPMethod *Arena::CreateMaybeMessage<::nrpc::HTTPMethod>(Arena *arena)
{
  return Arena::CreateMessageInternal<::nrpc::HTTPMethod>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
